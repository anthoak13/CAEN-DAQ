///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//                            Copyright (C) 2016                             //
//                    Adam Anthoony : All rights reserved                    //
//                                                                           //
//     This source code is licensed under the GNU GPL v3.0.You have the      //
//     right to modify and/or redistribute this source code under the terms  //
//     specified in the license, which may be found online at                //
//     http://www.gnu.org/licenses.                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//Implementation of wavedump config class

#include "WavedumpConfig.h"
using namespace std;
ClassImp(WavedumpConfig);
ClassImp(ChannelConfig);
WavedumpConfig::WavedumpConfig(TString name)
{
    setOutput(true, false, false, 1023);
    setGnuPlotPath("./");
    setConfig(ChannelTrigger::DSBLD, 1, 50, true, 0, true);
    setInput(true, 0, 0, false);
    fileName = name;
}

WavedumpConfig::~WavedumpConfig()
{

}

void WavedumpConfig::setInput(Bool_t USB, UInt_t int1, UInt_t int2,
			      Bool_t hex, UInt_t int3)
{
    _USB = USB;
    _digitizerLoc.clear();
    _digitizerLoc.push_back(int1);
    _digitizerLoc.push_back(int2);
    if(!USB)
	_digitizerLoc.push_back(int3);
    _hexLocation = hex;
}

void WavedumpConfig::setOutput(Bool_t binary, Bool_t header, Bool_t testPattern,
			       UShort_t recordLength)
{
    _binary = binary;
    _header = header;
    _testPattern = testPattern;
    _recordLength = recordLength;
}


void WavedumpConfig::setConfig(ChannelTrigger extTrig, UShort_t eventsUntilFlush,
			       UChar_t postTrig, Bool_t trigOnRise, UShort_t interrupt,
			       Bool_t NIM)
{
    _extTrig = extTrig;
    if(eventsUntilFlush > 0 && eventsUntilFlush < 1024)
	_maxEvents = eventsUntilFlush;
    if( postTrig <= 100)
	_postTrig = postTrig;
    _trigRising = trigOnRise;
    if(interrupt < 1024)
	_interrupt = interrupt;
    _NIM = NIM;
    
}

void WavedumpConfig::setGlobalChan(const ChannelConfig &chIn)
{
    globalChan = chIn;
}

void WavedumpConfig::addChannel(UInt_t chNum, const ChannelConfig &chIn)
{
    chConfigs[chNum] = chIn;
}

void WavedumpConfig::write()
{
    ofstream file(fileName);
    time_t t = time(0);
    struct tm *now = localtime(&t);

    //Create the header
    file << "# *************************************************" << endl;
    file << "# Wavedump config generated by GUI " << endl;
    file << "# Created on: " << now->tm_mon + 1 << "/" << now->tm_mday << "/"
	 << now->tm_year - 100 << endl;
    file << "# *************************************************" << endl;
    file << endl << endl << endl;

    file << "# -------------------------------------------------" << endl;
    file << "# Settings common to entire DAC" << endl;
    file << "# -------------------------------------------------" << endl;

    file << "[COMMON]" << endl << endl;

    //Write USB/PCI location
    file << "OPEN  ";
    if(_USB)
	file << "USB " << _digitizerLoc[0] << " ";
    else
	file << "PCI " << _digitizerLoc[0] << " " << _digitizerLoc[1] << " ";
    if(_hexLocation)
	file << std::hex << setw(8) << setfill('0');
    file << ( _USB ? _digitizerLoc[1] : _digitizerLoc[2]) <<
	std::dec << setw(0) << endl << endl;

    //Write out the gnu plot path
    file << "GNUPLOT_PATH  " << "\"" << gnuPlotPath << "\"" << endl << endl;

    //Write out file format
    file << "OUTPUT_FILE_FORMAT  " << (_binary ? "BINARY" : "ASCII") << endl << endl;

    //write out header
    file << "OUTPUT_FILE_HEADER " << (_header ? "YES" : "NO") << endl << endl;

    //output the record length
    file << "RECORD_LENGTH  " << _recordLength << endl << endl;

    //output test signal
    file << "TEST_PATTERN  " << (_testPattern ? "YES" : "NO") << endl << endl;

    //TODO:add in des mode flag for 731 and 751

    //output acq mode
    file << "EXTERNAL_TRIGGER  ";
    switch(_extTrig)
    {
    case DSBLD:
	file << "DISABLED";
	break;
    case ACQ:
	file << "ACQUISITION_ONLY";
	break;
    case ACQ_TRGOUT:
	file << "ACQUISITION_AND_TRGOUT";
	break;
    }
    file << endl << endl;

    //output max events
    file << "MAX_NUM_EVENTS_BLT  " << _maxEvents << endl << endl;

    //output post trigger
    file << "POST_TRIGGER  " << (int) _postTrig << endl << endl;

    //Output trigger edge
    file << "TRIGGER_EDGE  " << ( _trigRising ? "RISING" : "FALLING" )
	 << endl << endl;

    //output use interrupt
    file << "USE_INTERRUPT  " << _interrupt << endl << endl;

    //output fpio level
    file << "FPIO_LEVEL  " << ( _NIM ? "NIM" : "TTL" ) << endl << endl;

    //Write global channel
    file << "# ------------------------------------------------- " << endl;
    file << "# Default setting for every channel, can be overridden"
	 << endl << "# in the next section on a channel by channel basis"
	 << endl << "#!" << endl << endl;

    globalChan.write(file);

    file << "# -------------------------------------------------"
	 << endl << "# Individual channel settings, end with \"##\"" << endl << endl;

    for (auto&& ch:chConfigs)
    {
	file << "[" << ch.first << "]" << endl;
	ch.second.write(file);
    }
}

void WavedumpConfig::read()
{
    Bool_t common = false;
    Bool_t success = true;
    ifstream file(fileName);

    while (!file.eof())
    {
	TString lineIn;
        lineIn.ReadLine(file);
	if(lineIn[0] == '#')
	{
	    if(lineIn[1] == '!') //Read in global ch
		globalChan.read(file);
	    continue;
	}

	//Have line with data to read in so get id
	TString id, result;
	Ssiz_t from = 0;
	lineIn.Tokenize(id, from, " +");
	lineIn.Tokenize(result, from, " +");

	if(id == "[COMMON]")
	    common = true;
	
	if(id == "OPEN")
	{
	    //Get type to load
	    if(result == "USB") _USB = true;
	    else if(result == "PCI") _USB = false;
	    else
		success &= false;

	    //now that we know if USB read in integers
	    lineIn.Tokenize(result, from, " +");
	    _digitizerLoc.push_back(result.Atoi());
	    lineIn.Tokenize(result, from, " +");
	    _digitizerLoc.push_back(result.Atoi());
	    lineIn.Tokenize(result, from, " +");
	    if(!_USB)
		_digitizerLoc.push_back(result.Atoi());
	    _hexLocation = false;
	}
	
	if(id == "GNUPLOT_PATH")
	{
	    gnuPlotPath = result(1, result.Length()-2);
	}

	if(id == "OUTPUT_FILE_FORMAT")
	{
	    if(result == "BINARY") _binary = true;
	    else if( result == "ASCII" ) _binary = false;
	    else success &= false;
	}

	if(id == "OUTPUT_FILE_HEADER")
	{
	    if(result == "YES") _header = true;
	    else if( result == "NO" ) _header = false;
	    else success &= false;
	}

	if(id == "RECORD_BUFFER")
	{
	    _recordLength = result.Atoi();
	}

	if(id == "TEST_PATTERN")
	{
	    if(result == "YES") _testPattern = true;
	    else if( result == "NO" ) _testPattern = false;
	    else success &= false;
	}

	if(id == "EXTERNAL_TRIGGER")
	{
	    if(result == "DISABLED") _extTrig = DSBLD;
	    else if ( result == "ACQUISITION_ONLY" ) _extTrig = ACQ;
	    else if ( result == "ACQUISITION_AND_TRGOUT" ) _extTrig = ACQ_TRGOUT;
	    else success &= false;
	}

	if(id == "MAX_NUM_EVENTS_BLT")
	{
	    _maxEvents =  result.Atoi();
	}

	if(id == "POST_TRIGGER")
	{
	    _postTrig = result.Atoi();
	}

	if(id == "TRIGGER_EDGE")
	{
	    if(result == "RISING") _trigRising = true;
	    else if( result == "FALLING" ) _trigRising = false;
	    else success &= false;
	}

	if(id == "USE_INTERRUPT")
	{
	    _interrupt = result.Atoi();
	}

	if(id == "FPIO_LEVEL")
	{
	    if(result == "NIM") _NIM = true;
	    else if( result == "TTL" ) _NIM = false;
	    else success &= false;
	}
	if(id.Contains(TRegexp("\\[[0-9]*\\]")))
	{
	    common = false;
	    //We have a channel to read, get ch number
	    Ssiz_t chan = id.Index(TRegexp("\\[[0-9]*\\]"));
	    chan = TString(id(1, id.Length() - 2)).Atoi();
	    std::cout << "Found ch: " << chan << endl;
	    //Add channel to map
	    ChannelConfig temp;
	    temp.read(file);
	    chConfigs[chan] = temp;
	}
	
	if(!success)
	    throw std::runtime_error("file formatted incorrectly");
    }
}

void ChannelConfig::write(ofstream &file)
{
    file << "ENABLE_INPUT  " << ( enabled ? "YES" : "NO" ) << endl;

    file << "DC_OFFSET  " << DCOffset << endl;

    file << "TRIGGER_THRESHOLD  " << triggerThreshold << endl;

    file << "CHANNEL_TRIGGER  ";
    switch(triggerSetting)
    {
    case DSBLD:
	file << "DISABLED";
	break;
    case ACQ:
	file << "ACQUISITION_ONLY";
	break;
    case ACQ_TRGOUT:
	file << "ACQUISITION_AND_TRGOUT";
	break;
    }
    file << endl << "##" << endl << endl;
}

void ChannelConfig::read(ifstream &file)
{
    bool success =true;
    while (!file.eof())
    {
	TString lineIn;
        lineIn.ReadLine(file);
	if(lineIn[0] == '#')
	{
	    if(lineIn[1] == '#') //Reached end of channel
	        return;
	    continue;
	}

	//Have line with data to read in so get id
	TString id, result;
	Ssiz_t from = 0;
	lineIn.Tokenize(id, from, " +");
	lineIn.Tokenize(result, from, " +");

	if(id == "ENABLE_INPUT")
	{
	    if(result == "YES") enabled = true;
	    else if( result == "NO" ) enabled = false;
	    else success &= false;
	}

	if( id == "DC_OFFSET")
	{
	    DCOffset = result.Atof();
	}

	if( id == "TRIGGER_THRESHOLD" )
	{
	    triggerThreshold = result.Atoi();
	}

	if(id == "CHANNEL_TRIGGER" )
	{
	    if(result == "DISABLED") triggerSetting = DSBLD;
	    else if ( result == "ACQUISITION_ONLY" ) triggerSetting = ACQ;
	    else if ( result == "ACQUISITION_AND_TRGOUT" ) triggerSetting = ACQ_TRGOUT;
	    else success &= false;
	}

	if(!success)
	    throw std::runtime_error("file formatted incorrectly");
    }
}
